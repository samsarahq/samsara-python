# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from ..core.serialization import FieldMetadata
from .field_types_object_response_body_field_type import FieldTypesObjectResponseBodyFieldType
from .multiple_choice_field_type_meta_data_object_response_body import MultipleChoiceFieldTypeMetaDataObjectResponseBody
from .number_field_type_meta_data_object_response_body import NumberFieldTypeMetaDataObjectResponseBody
from .signature_field_type_meta_data_object_response_body import SignatureFieldTypeMetaDataObjectResponseBody


class FieldTypesObjectResponseBody(UniversalBaseModel):
    field_type: typing_extensions.Annotated[
        FieldTypesObjectResponseBodyFieldType,
        FieldMetadata(alias="fieldType"),
        pydantic.Field(
            alias="fieldType",
            description="The type of value this field can have.  Valid values: `photo`, `string`, `number`, `multipleChoice`, `signature`, `dateTime`, `scannedDocument`, `barcode`",
        ),
    ]
    label: str = pydantic.Field()
    """
    The name of the field type.
    """

    multiple_choice_field_type_meta_data: typing_extensions.Annotated[
        typing.Optional[typing.List[MultipleChoiceFieldTypeMetaDataObjectResponseBody]],
        FieldMetadata(alias="multipleChoiceFieldTypeMetaData"),
        pydantic.Field(
            alias="multipleChoiceFieldTypeMetaData", description="A list of the multiple choice field option labels."
        ),
    ] = None
    number_field_type_meta_data: typing_extensions.Annotated[
        typing.Optional[NumberFieldTypeMetaDataObjectResponseBody],
        FieldMetadata(alias="numberFieldTypeMetaData"),
        pydantic.Field(alias="numberFieldTypeMetaData"),
    ] = None
    required_field: typing_extensions.Annotated[
        bool,
        FieldMetadata(alias="requiredField"),
        pydantic.Field(alias="requiredField", description="The indicator that states if the field is required."),
    ]
    signature_field_type_meta_data: typing_extensions.Annotated[
        typing.Optional[SignatureFieldTypeMetaDataObjectResponseBody],
        FieldMetadata(alias="signatureFieldTypeMetaData"),
        pydantic.Field(alias="signatureFieldTypeMetaData"),
    ] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
