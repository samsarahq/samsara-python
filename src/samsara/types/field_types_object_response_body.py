# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from ..core.serialization import FieldMetadata
from .field_types_object_response_body_field_type import FieldTypesObjectResponseBodyFieldType
from .multiple_choice_field_type_meta_data_object_response_body import MultipleChoiceFieldTypeMetaDataObjectResponseBody
from .number_field_type_meta_data_object_response_body import NumberFieldTypeMetaDataObjectResponseBody
from .signature_field_type_meta_data_object_response_body import SignatureFieldTypeMetaDataObjectResponseBody


class FieldTypesObjectResponseBody(UniversalBaseModel):
    field_type: typing_extensions.Annotated[FieldTypesObjectResponseBodyFieldType, FieldMetadata(alias="fieldType")] = (
        pydantic.Field()
    )
    """
    The type of value this field can have.  Valid values: `photo`, `string`, `number`, `multipleChoice`, `signature`, `dateTime`, `scannedDocument`, `barcode`
    """

    label: str = pydantic.Field()
    """
    The name of the field type.
    """

    multiple_choice_field_type_meta_data: typing_extensions.Annotated[
        typing.Optional[typing.List[MultipleChoiceFieldTypeMetaDataObjectResponseBody]],
        FieldMetadata(alias="multipleChoiceFieldTypeMetaData"),
    ] = pydantic.Field(default=None)
    """
    A list of the multiple choice field option labels.
    """

    number_field_type_meta_data: typing_extensions.Annotated[
        typing.Optional[NumberFieldTypeMetaDataObjectResponseBody], FieldMetadata(alias="numberFieldTypeMetaData")
    ] = None
    required_field: typing_extensions.Annotated[bool, FieldMetadata(alias="requiredField")] = pydantic.Field()
    """
    The indicator that states if the field is required.
    """

    signature_field_type_meta_data: typing_extensions.Annotated[
        typing.Optional[SignatureFieldTypeMetaDataObjectResponseBody], FieldMetadata(alias="signatureFieldTypeMetaData")
    ] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
