# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from ..core.serialization import FieldMetadata
from .forms_conditional_action_object_response_body import FormsConditionalActionObjectResponseBody
from .forms_field_definition_object_response_body_allowed_asset_types_item import (
    FormsFieldDefinitionObjectResponseBodyAllowedAssetTypesItem,
)
from .forms_field_definition_object_response_body_allowed_date_time_value_type import (
    FormsFieldDefinitionObjectResponseBodyAllowedDateTimeValueType,
)
from .forms_field_definition_object_response_body_type import FormsFieldDefinitionObjectResponseBodyType
from .forms_select_option_object_response_body import FormsSelectOptionObjectResponseBody
from .forms_table_field_definition_object_response_body import FormsTableFieldDefinitionObjectResponseBody


class FormsFieldDefinitionObjectResponseBody(UniversalBaseModel):
    """
    Forms field definition object.
    """

    allow_manual_entry: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="allowManualEntry"),
        pydantic.Field(
            alias="allowManualEntry",
            description="Indicates whether the field allows manual entry of a person. Only present for person fields.",
        ),
    ] = None
    allowed_asset_types: typing_extensions.Annotated[
        typing.Optional[typing.List[FormsFieldDefinitionObjectResponseBodyAllowedAssetTypesItem]],
        FieldMetadata(alias="allowedAssetTypes"),
        pydantic.Field(
            alias="allowedAssetTypes",
            description="List of allowed asset types that can be selected for this field. Only present for asset fields.",
        ),
    ] = None
    allowed_date_time_value_type: typing_extensions.Annotated[
        typing.Optional[FormsFieldDefinitionObjectResponseBodyAllowedDateTimeValueType],
        FieldMetadata(alias="allowedDateTimeValueType"),
        pydantic.Field(
            alias="allowedDateTimeValueType",
            description="Type of date/time entry allowed for this question. Only present for datetime fields.  Valid values: `datetime`, `date`, `time`",
        ),
    ] = None
    autofill_from_id: typing_extensions.Annotated[
        typing.Optional[str],
        FieldMetadata(alias="autofillFromId"),
        pydantic.Field(
            alias="autofillFromId",
            description="Identifier of the field that will optionally autofill the current field. Only present for fields that have been configured to be autofilled by a source media field.",
        ),
    ] = None
    columns: typing.Optional[typing.List[FormsTableFieldDefinitionObjectResponseBody]] = pydantic.Field(default=None)
    """
    List of columns in the table field.
    """

    conditional_actions: typing_extensions.Annotated[
        typing.Optional[typing.List[FormsConditionalActionObjectResponseBody]],
        FieldMetadata(alias="conditionalActions"),
        pydantic.Field(alias="conditionalActions", description="List of conditional actions."),
    ] = None
    filter_by_role_ids: typing_extensions.Annotated[
        typing.Optional[typing.List[str]],
        FieldMetadata(alias="filterByRoleIds"),
        pydantic.Field(
            alias="filterByRoleIds",
            description="List of role IDs to filter org users by, representing which roles are selectable people for this field. Only present for person fields.",
        ),
    ] = None
    id: str = pydantic.Field()
    """
    Identifier of the field.
    """

    include_drivers: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="includeDrivers"),
        pydantic.Field(
            alias="includeDrivers",
            description="Indicates whether the field includes drivers as selectable people. Only present for person fields.",
        ),
    ] = None
    include_users: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="includeUsers"),
        pydantic.Field(
            alias="includeUsers",
            description="Indicates whether the field includes users as selectable people. Only present for person fields.",
        ),
    ] = None
    is_autofill_source: typing_extensions.Annotated[
        typing.Optional[bool],
        FieldMetadata(alias="isAutofillSource"),
        pydantic.Field(
            alias="isAutofillSource",
            description="Indicates whether the current field is enabled to autofill other fields. Only present for media fields that have autofill enabled.",
        ),
    ] = None
    is_required: typing_extensions.Annotated[
        bool,
        FieldMetadata(alias="isRequired"),
        pydantic.Field(
            alias="isRequired", description="Indicates whether the form field is required to be filled out by the user."
        ),
    ]
    label: str = pydantic.Field()
    """
    Label of the field.
    """

    num_decimal_places: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="numDecimalPlaces"),
        pydantic.Field(
            alias="numDecimalPlaces", description="Number of decimal places allowed. Only present for number fields."
        ),
    ] = None
    options: typing.Optional[typing.List[FormsSelectOptionObjectResponseBody]] = pydantic.Field(default=None)
    """
    List of select options for check boxes or multiple choice fields.
    """

    question_weight: typing_extensions.Annotated[
        typing.Optional[int],
        FieldMetadata(alias="questionWeight"),
        pydantic.Field(
            alias="questionWeight",
            description="The maximum possible score weight for this field. For multiple choice fields, this number is the highest option score weight of the given options. For check boxes fields, this number is the sum of the score weights for all scored options. Only present for multiple choice or check boxes fields that have scoring.",
        ),
    ] = None
    type: FormsFieldDefinitionObjectResponseBodyType = pydantic.Field()
    """
    Type of the field.  Valid values: `number`, `text`, `multiple_choice`, `check_boxes`, `media`, `datetime`, `signature`, `asset`, `person`, `geofence`, `instruction`, `media_instruction`, `table`
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
