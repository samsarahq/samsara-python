# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, BaseHttpResponse, SyncPager
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_gateway_error import BadGatewayError
from ..errors.gateway_timeout_error import GatewayTimeoutError
from ..errors.internal_server_error import InternalServerError
from ..errors.method_not_allowed_error import MethodNotAllowedError
from ..errors.not_found_error import NotFoundError
from ..errors.not_implemented_error import NotImplementedError
from ..errors.service_unavailable_error import ServiceUnavailableError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.create_driver_request_attributes import CreateDriverRequestAttributes
from ..types.driver import Driver
from ..types.driver_carrier_settings import DriverCarrierSettings
from ..types.driver_has_driving_features_hidden import DriverHasDrivingFeaturesHidden
from ..types.driver_hos_setting import DriverHosSetting
from ..types.driver_remote_signout_post_driver_remote_signout_response_body import (
    DriverRemoteSignoutPostDriverRemoteSignoutResponseBody,
)
from ..types.driver_response import DriverResponse
from ..types.list_drivers_response import ListDriversResponse
from ..types.update_driver_request_hos_setting import UpdateDriverRequestHosSetting
from ..types.us_driver_ruleset_override import UsDriverRulesetOverride
from .types.create_driver_request_locale import CreateDriverRequestLocale
from .types.drivers_list_request_driver_activation_status import DriversListRequestDriverActivationStatus
from .types.update_driver_request_driver_activation_status import UpdateDriverRequestDriverActivationStatus
from .types.update_driver_request_locale import UpdateDriverRequestLocale

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawDriversClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        driver_activation_status: typing.Optional[DriversListRequestDriverActivationStatus] = None,
        limit: typing.Optional[int] = None,
        after: typing.Optional[str] = None,
        parent_tag_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        tag_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        attribute_value_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        attributes: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        updated_after_time: typing.Optional[str] = None,
        created_after_time: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[Driver]:
        """
        Get all drivers in organization.

         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        To use this endpoint, select **Read Drivers** under the Drivers category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>

        Parameters
        ----------
        driver_activation_status : typing.Optional[DriversListRequestDriverActivationStatus]
            If value is `deactivated`, only drivers that are deactivated will appear in the response. This parameter will default to `active` if not provided (fetching only active drivers).

        limit : typing.Optional[int]
            The limit for how many objects will be in the response. Default and max for this value is 512 objects.

        after : typing.Optional[str]
            If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.

        parent_tag_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`

        tag_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`

        attribute_value_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A filter on the data based on this comma-separated list of attribute value IDs. Only entities associated with ALL of the referenced values will be returned (i.e. the intersection of the sets of entities with each value). Example: `attributeValueIds=076efac2-83b5-47aa-ba36-18428436dcac,6707b3f0-23b9-4fe3-b7be-11be34aea544`

        attributes : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A filter on the data to return entities having given attributes using name-value pair, separated by semicolon. Only entities associated with ALL of the referenced values will be returned (i.e. the intersection of the sets of entities with each value). Example: `attributes=ExampleAttributeName:some_value&attributes=SomeOtherAttr:123`

        updated_after_time : typing.Optional[str]
            A filter on data to have an updated at time after or equal to this specified time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).

        created_after_time : typing.Optional[str]
            A filter on data to have a created at time after or equal to this specified time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[Driver]
            List of all driver objects.
        """
        _response = self._client_wrapper.httpx_client.request(
            "fleet/drivers",
            method="GET",
            params={
                "driverActivationStatus": driver_activation_status,
                "limit": limit,
                "after": after,
                "parentTagIds": parent_tag_ids,
                "tagIds": tag_ids,
                "attributeValueIds": attribute_value_ids,
                "attributes": attributes,
                "updatedAfterTime": updated_after_time,
                "createdAfterTime": created_after_time,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListDriversResponse,
                    parse_obj_as(
                        type_=ListDriversResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.data
                _has_next = False
                _get_next = None
                if _parsed_response.pagination is not None:
                    _parsed_next = _parsed_response.pagination.end_cursor
                    _has_next = _parsed_next is not None and _parsed_next != ""
                    _get_next = lambda: self.list(
                        driver_activation_status=driver_activation_status,
                        limit=limit,
                        after=_parsed_next,
                        parent_tag_ids=parent_tag_ids,
                        tag_ids=tag_ids,
                        attribute_value_ids=attribute_value_ids,
                        attributes=attributes,
                        updated_after_time=updated_after_time,
                        created_after_time=created_after_time,
                        request_options=request_options,
                    )
                return SyncPager(
                    has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        name: str,
        password: str,
        username: str,
        attributes: typing.Optional[typing.Sequence[CreateDriverRequestAttributes]] = OMIT,
        carrier_settings: typing.Optional[DriverCarrierSettings] = OMIT,
        current_id_card_code: typing.Optional[str] = OMIT,
        eld_adverse_weather_exemption_enabled: typing.Optional[bool] = OMIT,
        eld_big_day_exemption_enabled: typing.Optional[bool] = OMIT,
        eld_day_start_hour: typing.Optional[int] = OMIT,
        eld_exempt: typing.Optional[bool] = OMIT,
        eld_exempt_reason: typing.Optional[str] = OMIT,
        eld_pc_enabled: typing.Optional[bool] = OMIT,
        eld_ym_enabled: typing.Optional[bool] = OMIT,
        external_ids: typing.Optional[typing.Dict[str, str]] = OMIT,
        has_driving_features_hidden: typing.Optional[DriverHasDrivingFeaturesHidden] = OMIT,
        hos_setting: typing.Optional[DriverHosSetting] = OMIT,
        license_number: typing.Optional[str] = OMIT,
        license_state: typing.Optional[str] = OMIT,
        locale: typing.Optional[CreateDriverRequestLocale] = OMIT,
        notes: typing.Optional[str] = OMIT,
        peer_group_tag_id: typing.Optional[str] = OMIT,
        phone: typing.Optional[str] = OMIT,
        static_assigned_vehicle_id: typing.Optional[str] = OMIT,
        tachograph_card_number: typing.Optional[str] = OMIT,
        tag_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        us_driver_ruleset_override: typing.Optional[UsDriverRulesetOverride] = OMIT,
        vehicle_group_tag_id: typing.Optional[str] = OMIT,
        waiting_time_duty_status_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DriverResponse]:
        """
        Add a driver to the organization.

         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        To use this endpoint, select **Write Drivers** under the Drivers category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>

        Parameters
        ----------
        name : str
            Driver's name.

        password : str
            Password that the driver can use to login to the Samsara driver app.

        username : str
            Driver's login username into the driver app. The username may not contain spaces or the '@' symbol. The username must be unique.

        attributes : typing.Optional[typing.Sequence[CreateDriverRequestAttributes]]

        carrier_settings : typing.Optional[DriverCarrierSettings]

        current_id_card_code : typing.Optional[str]
            The ID Card Code on the back of the physical card assigned to the driver.  Contact Samsara if you would like to enable this feature.

        eld_adverse_weather_exemption_enabled : typing.Optional[bool]
            Flag indicating this driver may use Adverse Weather exemptions in ELD logs.

        eld_big_day_exemption_enabled : typing.Optional[bool]
            Flag indicating this driver may use Big Day exemption in ELD logs.

        eld_day_start_hour : typing.Optional[int]
            `0` indicating midnight-to-midnight ELD driving hours, `12` to indicate noon-to-noon driving hours.

        eld_exempt : typing.Optional[bool]
            Flag indicating this driver is exempt from the Electronic Logging Mandate.

        eld_exempt_reason : typing.Optional[str]
            Reason that this driver is exempt from the Electronic Logging Mandate (see eldExempt).

        eld_pc_enabled : typing.Optional[bool]
            Flag indicating this driver may select the Personal Conveyance duty status in ELD logs.

        eld_ym_enabled : typing.Optional[bool]
            Flag indicating this driver may select the Yard Move duty status in ELD logs.

        external_ids : typing.Optional[typing.Dict[str, str]]
            The [external IDs](https://developers.samsara.com/docs/external-ids) for the given object.

        has_driving_features_hidden : typing.Optional[DriverHasDrivingFeaturesHidden]

        hos_setting : typing.Optional[DriverHosSetting]

        license_number : typing.Optional[str]
            Driver's state issued license number. The combination of this number and `licenseState` must be unique.

        license_state : typing.Optional[str]
            Abbreviation of US state, Canadian province, or US territory that issued driver's license.

        locale : typing.Optional[CreateDriverRequestLocale]
            Locale override (uncommon). These are specified by ISO 3166-2 country codes for supported locales. Valid values: `us`, `at`, `be`, `ca`, `gb`, `fr`, `de`, `ie`, `it`, `lu`, `mx`, `nl`, `es`, `ch`, `pr`.

        notes : typing.Optional[str]
            Notes about the driver.

        peer_group_tag_id : typing.Optional[str]
            The peer group tag id this driver belong to, used for gamification.

        phone : typing.Optional[str]
            Phone number of the driver.

        static_assigned_vehicle_id : typing.Optional[str]
            ID of vehicle that the driver is permanently assigned to. (uncommon).

        tachograph_card_number : typing.Optional[str]
            Driver's assigned tachograph card number (Europe specific)

        tag_ids : typing.Optional[typing.Sequence[str]]
            IDs of tags the driver is associated with. If your access to the API is scoped by one or more tags, this field is required to pass in.

        timezone : typing.Optional[str]
            Home terminal timezone, in order to indicate what time zone should be used to calculate the ELD logs. Driver timezones use [IANA timezone database](https://www.iana.org/time-zones) keys (e.g. `America/Los_Angeles`, `America/New_York`, `Europe/London`, etc.). You can find a mapping of common timezone formats to IANA timezone keys [here](https://unicode.org/cldr/charts/latest/supplemental/zone_tzid.html).

        us_driver_ruleset_override : typing.Optional[UsDriverRulesetOverride]

        vehicle_group_tag_id : typing.Optional[str]
            Tag ID which determines which vehicles a driver will see when selecting vehicles.

        waiting_time_duty_status_enabled : typing.Optional[bool]
            Flag indicating this driver may select waiting time duty status in ELD logs

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DriverResponse]
            Newly created driver object, with Samsara-generated ID.
        """
        _response = self._client_wrapper.httpx_client.request(
            "fleet/drivers",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes, annotation=typing.Sequence[CreateDriverRequestAttributes], direction="write"
                ),
                "carrierSettings": convert_and_respect_annotation_metadata(
                    object_=carrier_settings, annotation=DriverCarrierSettings, direction="write"
                ),
                "currentIdCardCode": current_id_card_code,
                "eldAdverseWeatherExemptionEnabled": eld_adverse_weather_exemption_enabled,
                "eldBigDayExemptionEnabled": eld_big_day_exemption_enabled,
                "eldDayStartHour": eld_day_start_hour,
                "eldExempt": eld_exempt,
                "eldExemptReason": eld_exempt_reason,
                "eldPcEnabled": eld_pc_enabled,
                "eldYmEnabled": eld_ym_enabled,
                "externalIds": external_ids,
                "hasDrivingFeaturesHidden": has_driving_features_hidden,
                "hosSetting": convert_and_respect_annotation_metadata(
                    object_=hos_setting, annotation=DriverHosSetting, direction="write"
                ),
                "licenseNumber": license_number,
                "licenseState": license_state,
                "locale": locale,
                "name": name,
                "notes": notes,
                "password": password,
                "peerGroupTagId": peer_group_tag_id,
                "phone": phone,
                "staticAssignedVehicleId": static_assigned_vehicle_id,
                "tachographCardNumber": tachograph_card_number,
                "tagIds": tag_ids,
                "timezone": timezone,
                "usDriverRulesetOverride": convert_and_respect_annotation_metadata(
                    object_=us_driver_ruleset_override, annotation=UsDriverRulesetOverride, direction="write"
                ),
                "username": username,
                "vehicleGroupTagId": vehicle_group_tag_id,
                "waitingTimeDutyStatusEnabled": waiting_time_duty_status_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DriverResponse,
                    parse_obj_as(
                        type_=DriverResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def sign_out(
        self, *, driver_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DriverRemoteSignoutPostDriverRemoteSignoutResponseBody]:
        """
        Sign out a driver from the Samsara Driver App

        To access this endpoint, your organization must have the Samsara Platform Premier license.

        Note: Sign out requests made while a logged-in driver does not have internet connection will not log the driver out. A success response will still be provided and the driver will be logged out once they have internet connection.

         <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href="https://developers.samsara.com/docs/rate-limits" target="_blank">here</a>).

        To use this endpoint, select **Write Driver Remote Signout** under the Closed Beta category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>


         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        Parameters
        ----------
        driver_id : str
            ID of the driver.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DriverRemoteSignoutPostDriverRemoteSignoutResponseBody]
            OK response.
        """
        _response = self._client_wrapper.httpx_client.request(
            "fleet/drivers/remote-sign-out",
            method="POST",
            json={
                "driverId": driver_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DriverRemoteSignoutPostDriverRemoteSignoutResponseBody,
                    parse_obj_as(
                        type_=DriverRemoteSignoutPostDriverRemoteSignoutResponseBody,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 501:
                raise NotImplementedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 502:
                raise BadGatewayError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 504:
                raise GatewayTimeoutError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[DriverResponse]:
        """
        Get information about a driver.

         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        To use this endpoint, select **Read Drivers** under the Drivers category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>

        Parameters
        ----------
        id : str
            ID of the driver. This can either be the Samsara-specified ID, or an external ID. External IDs are customer specified key-value pairs created in the POST or PATCH requests of this resource. To specify an external ID as part of a path parameter, use the following format: `key:value`. For example, `payrollId:ABFS18600`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DriverResponse]
            Returns the specified driver.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"fleet/drivers/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DriverResponse,
                    parse_obj_as(
                        type_=DriverResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        id: str,
        *,
        attributes: typing.Optional[typing.Sequence[CreateDriverRequestAttributes]] = OMIT,
        carrier_settings: typing.Optional[DriverCarrierSettings] = OMIT,
        current_id_card_code: typing.Optional[str] = OMIT,
        deactivated_at_time: typing.Optional[str] = OMIT,
        driver_activation_status: typing.Optional[UpdateDriverRequestDriverActivationStatus] = OMIT,
        eld_adverse_weather_exemption_enabled: typing.Optional[bool] = OMIT,
        eld_big_day_exemption_enabled: typing.Optional[bool] = OMIT,
        eld_day_start_hour: typing.Optional[int] = OMIT,
        eld_exempt: typing.Optional[bool] = OMIT,
        eld_exempt_reason: typing.Optional[str] = OMIT,
        eld_pc_enabled: typing.Optional[bool] = OMIT,
        eld_ym_enabled: typing.Optional[bool] = OMIT,
        external_ids: typing.Optional[typing.Dict[str, str]] = OMIT,
        has_driving_features_hidden: typing.Optional[DriverHasDrivingFeaturesHidden] = OMIT,
        hos_setting: typing.Optional[UpdateDriverRequestHosSetting] = OMIT,
        license_number: typing.Optional[str] = OMIT,
        license_state: typing.Optional[str] = OMIT,
        locale: typing.Optional[UpdateDriverRequestLocale] = OMIT,
        name: typing.Optional[str] = OMIT,
        notes: typing.Optional[str] = OMIT,
        password: typing.Optional[str] = OMIT,
        peer_group_tag_id: typing.Optional[str] = OMIT,
        phone: typing.Optional[str] = OMIT,
        static_assigned_vehicle_id: typing.Optional[str] = OMIT,
        tachograph_card_number: typing.Optional[str] = OMIT,
        tag_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        us_driver_ruleset_override: typing.Optional[UsDriverRulesetOverride] = OMIT,
        username: typing.Optional[str] = OMIT,
        vehicle_group_tag_id: typing.Optional[str] = OMIT,
        waiting_time_duty_status_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DriverResponse]:
        """
        Update a specific driver's information. This can also be used to activate or de-activate a given driver by setting the driverActivationStatus field. If the driverActivationStatus field is 'deactivated' then the user can also specify the deactivatedAtTime. The deactivatedAtTime cannot be more than 6 months in the past and must not come before the dirver's latest active HOS log. It will be considered an error if deactivatedAtTime is provided with a driverActivationStatus of active.

         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        To use this endpoint, select **Write Drivers** under the Drivers category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>

        Parameters
        ----------
        id : str
            ID of the driver. This can either be the Samsara-specified ID, or an external ID. External IDs are customer specified key-value pairs created in the POST or PATCH requests of this resource. To specify an external ID as part of a path parameter, use the following format: `key:value`. For example, `payrollId:ABFS18600`

        attributes : typing.Optional[typing.Sequence[CreateDriverRequestAttributes]]

        carrier_settings : typing.Optional[DriverCarrierSettings]

        current_id_card_code : typing.Optional[str]
            The ID Card Code on the back of the physical card assigned to the driver.  Contact Samsara if you would like to enable this feature.

        deactivated_at_time : typing.Optional[str]
            The date and time this driver is considered to be deactivated in RFC 3339 format.

        driver_activation_status : typing.Optional[UpdateDriverRequestDriverActivationStatus]
            A value indicating whether the driver is active or deactivated. Valid values: `active`, `deactivated`.

        eld_adverse_weather_exemption_enabled : typing.Optional[bool]
            Flag indicating this driver may use Adverse Weather exemptions in ELD logs.

        eld_big_day_exemption_enabled : typing.Optional[bool]
            Flag indicating this driver may use Big Day exemption in ELD logs.

        eld_day_start_hour : typing.Optional[int]
            `0` indicating midnight-to-midnight ELD driving hours, `12` to indicate noon-to-noon driving hours.

        eld_exempt : typing.Optional[bool]
            Flag indicating this driver is exempt from the Electronic Logging Mandate.

        eld_exempt_reason : typing.Optional[str]
            Reason that this driver is exempt from the Electronic Logging Mandate (see eldExempt).

        eld_pc_enabled : typing.Optional[bool]
            Flag indicating this driver may select the Personal Conveyance duty status in ELD logs.

        eld_ym_enabled : typing.Optional[bool]
            Flag indicating this driver may select the Yard Move duty status in ELD logs.

        external_ids : typing.Optional[typing.Dict[str, str]]
            The [external IDs](https://developers.samsara.com/docs/external-ids) for the given object.

        has_driving_features_hidden : typing.Optional[DriverHasDrivingFeaturesHidden]

        hos_setting : typing.Optional[UpdateDriverRequestHosSetting]

        license_number : typing.Optional[str]
            Driver's state issued license number. The combination of this number and `licenseState` must be unique.

        license_state : typing.Optional[str]
            Abbreviation of US state, Canadian province, or US territory that issued driver's license.

        locale : typing.Optional[UpdateDriverRequestLocale]
            Locale override (uncommon). These are specified by ISO 3166-2 country codes for supported locales. Valid values: `us`, `at`, `be`, `ca`, `gb`, `fr`, `de`, `ie`, `it`, `lu`, `mx`, `nl`, `es`, `ch`, `pr`.

        name : typing.Optional[str]
            Driver's name.

        notes : typing.Optional[str]
            Notes about the driver.

        password : typing.Optional[str]
            Password that the driver can use to login to the Samsara driver app.

        peer_group_tag_id : typing.Optional[str]
            The peer group tag id this driver belong to, leave blank to be in group with everyone, used for gamification.

        phone : typing.Optional[str]
            Phone number of the driver.

        static_assigned_vehicle_id : typing.Optional[str]
            ID of vehicle that the driver is permanently assigned to. (uncommon).

        tachograph_card_number : typing.Optional[str]
            Driver's assigned tachograph card number (Europe specific)

        tag_ids : typing.Optional[typing.Sequence[str]]
            IDs of tags the driver is associated with. If your access to the API is scoped by one or more tags, this field is required to pass in.

        timezone : typing.Optional[str]
            Home terminal timezone, in order to indicate what time zone should be used to calculate the ELD logs. Driver timezones use [IANA timezone database](https://www.iana.org/time-zones) keys (e.g. `America/Los_Angeles`, `America/New_York`, `Europe/London`, etc.). You can find a mapping of common timezone formats to IANA timezone keys [here](https://unicode.org/cldr/charts/latest/supplemental/zone_tzid.html).

        us_driver_ruleset_override : typing.Optional[UsDriverRulesetOverride]

        username : typing.Optional[str]
            Driver's login username into the driver app. The username may not contain spaces or the '@' symbol. The username must be unique.

        vehicle_group_tag_id : typing.Optional[str]
            Tag ID which determines which vehicles a driver will see when selecting vehicles.

        waiting_time_duty_status_enabled : typing.Optional[bool]
            Flag indicating this driver may select waiting time duty status in ELD logs

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DriverResponse]
            Updated driver object, with ID.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"fleet/drivers/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes, annotation=typing.Sequence[CreateDriverRequestAttributes], direction="write"
                ),
                "carrierSettings": convert_and_respect_annotation_metadata(
                    object_=carrier_settings, annotation=DriverCarrierSettings, direction="write"
                ),
                "currentIdCardCode": current_id_card_code,
                "deactivatedAtTime": deactivated_at_time,
                "driverActivationStatus": driver_activation_status,
                "eldAdverseWeatherExemptionEnabled": eld_adverse_weather_exemption_enabled,
                "eldBigDayExemptionEnabled": eld_big_day_exemption_enabled,
                "eldDayStartHour": eld_day_start_hour,
                "eldExempt": eld_exempt,
                "eldExemptReason": eld_exempt_reason,
                "eldPcEnabled": eld_pc_enabled,
                "eldYmEnabled": eld_ym_enabled,
                "externalIds": external_ids,
                "hasDrivingFeaturesHidden": has_driving_features_hidden,
                "hosSetting": convert_and_respect_annotation_metadata(
                    object_=hos_setting, annotation=UpdateDriverRequestHosSetting, direction="write"
                ),
                "licenseNumber": license_number,
                "licenseState": license_state,
                "locale": locale,
                "name": name,
                "notes": notes,
                "password": password,
                "peerGroupTagId": peer_group_tag_id,
                "phone": phone,
                "staticAssignedVehicleId": static_assigned_vehicle_id,
                "tachographCardNumber": tachograph_card_number,
                "tagIds": tag_ids,
                "timezone": timezone,
                "usDriverRulesetOverride": convert_and_respect_annotation_metadata(
                    object_=us_driver_ruleset_override, annotation=UsDriverRulesetOverride, direction="write"
                ),
                "username": username,
                "vehicleGroupTagId": vehicle_group_tag_id,
                "waitingTimeDutyStatusEnabled": waiting_time_duty_status_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DriverResponse,
                    parse_obj_as(
                        type_=DriverResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawDriversClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        driver_activation_status: typing.Optional[DriversListRequestDriverActivationStatus] = None,
        limit: typing.Optional[int] = None,
        after: typing.Optional[str] = None,
        parent_tag_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        tag_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        attribute_value_ids: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        attributes: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        updated_after_time: typing.Optional[str] = None,
        created_after_time: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[Driver]:
        """
        Get all drivers in organization.

         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        To use this endpoint, select **Read Drivers** under the Drivers category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>

        Parameters
        ----------
        driver_activation_status : typing.Optional[DriversListRequestDriverActivationStatus]
            If value is `deactivated`, only drivers that are deactivated will appear in the response. This parameter will default to `active` if not provided (fetching only active drivers).

        limit : typing.Optional[int]
            The limit for how many objects will be in the response. Default and max for this value is 512 objects.

        after : typing.Optional[str]
            If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.

        parent_tag_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`

        tag_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`

        attribute_value_ids : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A filter on the data based on this comma-separated list of attribute value IDs. Only entities associated with ALL of the referenced values will be returned (i.e. the intersection of the sets of entities with each value). Example: `attributeValueIds=076efac2-83b5-47aa-ba36-18428436dcac,6707b3f0-23b9-4fe3-b7be-11be34aea544`

        attributes : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            A filter on the data to return entities having given attributes using name-value pair, separated by semicolon. Only entities associated with ALL of the referenced values will be returned (i.e. the intersection of the sets of entities with each value). Example: `attributes=ExampleAttributeName:some_value&attributes=SomeOtherAttr:123`

        updated_after_time : typing.Optional[str]
            A filter on data to have an updated at time after or equal to this specified time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).

        created_after_time : typing.Optional[str]
            A filter on data to have a created at time after or equal to this specified time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[Driver]
            List of all driver objects.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "fleet/drivers",
            method="GET",
            params={
                "driverActivationStatus": driver_activation_status,
                "limit": limit,
                "after": after,
                "parentTagIds": parent_tag_ids,
                "tagIds": tag_ids,
                "attributeValueIds": attribute_value_ids,
                "attributes": attributes,
                "updatedAfterTime": updated_after_time,
                "createdAfterTime": created_after_time,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListDriversResponse,
                    parse_obj_as(
                        type_=ListDriversResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.data
                _has_next = False
                _get_next = None
                if _parsed_response.pagination is not None:
                    _parsed_next = _parsed_response.pagination.end_cursor
                    _has_next = _parsed_next is not None and _parsed_next != ""

                    async def _get_next():
                        return await self.list(
                            driver_activation_status=driver_activation_status,
                            limit=limit,
                            after=_parsed_next,
                            parent_tag_ids=parent_tag_ids,
                            tag_ids=tag_ids,
                            attribute_value_ids=attribute_value_ids,
                            attributes=attributes,
                            updated_after_time=updated_after_time,
                            created_after_time=created_after_time,
                            request_options=request_options,
                        )

                return AsyncPager(
                    has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        name: str,
        password: str,
        username: str,
        attributes: typing.Optional[typing.Sequence[CreateDriverRequestAttributes]] = OMIT,
        carrier_settings: typing.Optional[DriverCarrierSettings] = OMIT,
        current_id_card_code: typing.Optional[str] = OMIT,
        eld_adverse_weather_exemption_enabled: typing.Optional[bool] = OMIT,
        eld_big_day_exemption_enabled: typing.Optional[bool] = OMIT,
        eld_day_start_hour: typing.Optional[int] = OMIT,
        eld_exempt: typing.Optional[bool] = OMIT,
        eld_exempt_reason: typing.Optional[str] = OMIT,
        eld_pc_enabled: typing.Optional[bool] = OMIT,
        eld_ym_enabled: typing.Optional[bool] = OMIT,
        external_ids: typing.Optional[typing.Dict[str, str]] = OMIT,
        has_driving_features_hidden: typing.Optional[DriverHasDrivingFeaturesHidden] = OMIT,
        hos_setting: typing.Optional[DriverHosSetting] = OMIT,
        license_number: typing.Optional[str] = OMIT,
        license_state: typing.Optional[str] = OMIT,
        locale: typing.Optional[CreateDriverRequestLocale] = OMIT,
        notes: typing.Optional[str] = OMIT,
        peer_group_tag_id: typing.Optional[str] = OMIT,
        phone: typing.Optional[str] = OMIT,
        static_assigned_vehicle_id: typing.Optional[str] = OMIT,
        tachograph_card_number: typing.Optional[str] = OMIT,
        tag_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        us_driver_ruleset_override: typing.Optional[UsDriverRulesetOverride] = OMIT,
        vehicle_group_tag_id: typing.Optional[str] = OMIT,
        waiting_time_duty_status_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DriverResponse]:
        """
        Add a driver to the organization.

         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        To use this endpoint, select **Write Drivers** under the Drivers category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>

        Parameters
        ----------
        name : str
            Driver's name.

        password : str
            Password that the driver can use to login to the Samsara driver app.

        username : str
            Driver's login username into the driver app. The username may not contain spaces or the '@' symbol. The username must be unique.

        attributes : typing.Optional[typing.Sequence[CreateDriverRequestAttributes]]

        carrier_settings : typing.Optional[DriverCarrierSettings]

        current_id_card_code : typing.Optional[str]
            The ID Card Code on the back of the physical card assigned to the driver.  Contact Samsara if you would like to enable this feature.

        eld_adverse_weather_exemption_enabled : typing.Optional[bool]
            Flag indicating this driver may use Adverse Weather exemptions in ELD logs.

        eld_big_day_exemption_enabled : typing.Optional[bool]
            Flag indicating this driver may use Big Day exemption in ELD logs.

        eld_day_start_hour : typing.Optional[int]
            `0` indicating midnight-to-midnight ELD driving hours, `12` to indicate noon-to-noon driving hours.

        eld_exempt : typing.Optional[bool]
            Flag indicating this driver is exempt from the Electronic Logging Mandate.

        eld_exempt_reason : typing.Optional[str]
            Reason that this driver is exempt from the Electronic Logging Mandate (see eldExempt).

        eld_pc_enabled : typing.Optional[bool]
            Flag indicating this driver may select the Personal Conveyance duty status in ELD logs.

        eld_ym_enabled : typing.Optional[bool]
            Flag indicating this driver may select the Yard Move duty status in ELD logs.

        external_ids : typing.Optional[typing.Dict[str, str]]
            The [external IDs](https://developers.samsara.com/docs/external-ids) for the given object.

        has_driving_features_hidden : typing.Optional[DriverHasDrivingFeaturesHidden]

        hos_setting : typing.Optional[DriverHosSetting]

        license_number : typing.Optional[str]
            Driver's state issued license number. The combination of this number and `licenseState` must be unique.

        license_state : typing.Optional[str]
            Abbreviation of US state, Canadian province, or US territory that issued driver's license.

        locale : typing.Optional[CreateDriverRequestLocale]
            Locale override (uncommon). These are specified by ISO 3166-2 country codes for supported locales. Valid values: `us`, `at`, `be`, `ca`, `gb`, `fr`, `de`, `ie`, `it`, `lu`, `mx`, `nl`, `es`, `ch`, `pr`.

        notes : typing.Optional[str]
            Notes about the driver.

        peer_group_tag_id : typing.Optional[str]
            The peer group tag id this driver belong to, used for gamification.

        phone : typing.Optional[str]
            Phone number of the driver.

        static_assigned_vehicle_id : typing.Optional[str]
            ID of vehicle that the driver is permanently assigned to. (uncommon).

        tachograph_card_number : typing.Optional[str]
            Driver's assigned tachograph card number (Europe specific)

        tag_ids : typing.Optional[typing.Sequence[str]]
            IDs of tags the driver is associated with. If your access to the API is scoped by one or more tags, this field is required to pass in.

        timezone : typing.Optional[str]
            Home terminal timezone, in order to indicate what time zone should be used to calculate the ELD logs. Driver timezones use [IANA timezone database](https://www.iana.org/time-zones) keys (e.g. `America/Los_Angeles`, `America/New_York`, `Europe/London`, etc.). You can find a mapping of common timezone formats to IANA timezone keys [here](https://unicode.org/cldr/charts/latest/supplemental/zone_tzid.html).

        us_driver_ruleset_override : typing.Optional[UsDriverRulesetOverride]

        vehicle_group_tag_id : typing.Optional[str]
            Tag ID which determines which vehicles a driver will see when selecting vehicles.

        waiting_time_duty_status_enabled : typing.Optional[bool]
            Flag indicating this driver may select waiting time duty status in ELD logs

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DriverResponse]
            Newly created driver object, with Samsara-generated ID.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "fleet/drivers",
            method="POST",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes, annotation=typing.Sequence[CreateDriverRequestAttributes], direction="write"
                ),
                "carrierSettings": convert_and_respect_annotation_metadata(
                    object_=carrier_settings, annotation=DriverCarrierSettings, direction="write"
                ),
                "currentIdCardCode": current_id_card_code,
                "eldAdverseWeatherExemptionEnabled": eld_adverse_weather_exemption_enabled,
                "eldBigDayExemptionEnabled": eld_big_day_exemption_enabled,
                "eldDayStartHour": eld_day_start_hour,
                "eldExempt": eld_exempt,
                "eldExemptReason": eld_exempt_reason,
                "eldPcEnabled": eld_pc_enabled,
                "eldYmEnabled": eld_ym_enabled,
                "externalIds": external_ids,
                "hasDrivingFeaturesHidden": has_driving_features_hidden,
                "hosSetting": convert_and_respect_annotation_metadata(
                    object_=hos_setting, annotation=DriverHosSetting, direction="write"
                ),
                "licenseNumber": license_number,
                "licenseState": license_state,
                "locale": locale,
                "name": name,
                "notes": notes,
                "password": password,
                "peerGroupTagId": peer_group_tag_id,
                "phone": phone,
                "staticAssignedVehicleId": static_assigned_vehicle_id,
                "tachographCardNumber": tachograph_card_number,
                "tagIds": tag_ids,
                "timezone": timezone,
                "usDriverRulesetOverride": convert_and_respect_annotation_metadata(
                    object_=us_driver_ruleset_override, annotation=UsDriverRulesetOverride, direction="write"
                ),
                "username": username,
                "vehicleGroupTagId": vehicle_group_tag_id,
                "waitingTimeDutyStatusEnabled": waiting_time_duty_status_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DriverResponse,
                    parse_obj_as(
                        type_=DriverResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def sign_out(
        self, *, driver_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DriverRemoteSignoutPostDriverRemoteSignoutResponseBody]:
        """
        Sign out a driver from the Samsara Driver App

        To access this endpoint, your organization must have the Samsara Platform Premier license.

        Note: Sign out requests made while a logged-in driver does not have internet connection will not log the driver out. A success response will still be provided and the driver will be logged out once they have internet connection.

         <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href="https://developers.samsara.com/docs/rate-limits" target="_blank">here</a>).

        To use this endpoint, select **Write Driver Remote Signout** under the Closed Beta category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>


         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        Parameters
        ----------
        driver_id : str
            ID of the driver.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DriverRemoteSignoutPostDriverRemoteSignoutResponseBody]
            OK response.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "fleet/drivers/remote-sign-out",
            method="POST",
            json={
                "driverId": driver_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DriverRemoteSignoutPostDriverRemoteSignoutResponseBody,
                    parse_obj_as(
                        type_=DriverRemoteSignoutPostDriverRemoteSignoutResponseBody,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 501:
                raise NotImplementedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 502:
                raise BadGatewayError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 504:
                raise GatewayTimeoutError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DriverResponse]:
        """
        Get information about a driver.

         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        To use this endpoint, select **Read Drivers** under the Drivers category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>

        Parameters
        ----------
        id : str
            ID of the driver. This can either be the Samsara-specified ID, or an external ID. External IDs are customer specified key-value pairs created in the POST or PATCH requests of this resource. To specify an external ID as part of a path parameter, use the following format: `key:value`. For example, `payrollId:ABFS18600`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DriverResponse]
            Returns the specified driver.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"fleet/drivers/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DriverResponse,
                    parse_obj_as(
                        type_=DriverResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        id: str,
        *,
        attributes: typing.Optional[typing.Sequence[CreateDriverRequestAttributes]] = OMIT,
        carrier_settings: typing.Optional[DriverCarrierSettings] = OMIT,
        current_id_card_code: typing.Optional[str] = OMIT,
        deactivated_at_time: typing.Optional[str] = OMIT,
        driver_activation_status: typing.Optional[UpdateDriverRequestDriverActivationStatus] = OMIT,
        eld_adverse_weather_exemption_enabled: typing.Optional[bool] = OMIT,
        eld_big_day_exemption_enabled: typing.Optional[bool] = OMIT,
        eld_day_start_hour: typing.Optional[int] = OMIT,
        eld_exempt: typing.Optional[bool] = OMIT,
        eld_exempt_reason: typing.Optional[str] = OMIT,
        eld_pc_enabled: typing.Optional[bool] = OMIT,
        eld_ym_enabled: typing.Optional[bool] = OMIT,
        external_ids: typing.Optional[typing.Dict[str, str]] = OMIT,
        has_driving_features_hidden: typing.Optional[DriverHasDrivingFeaturesHidden] = OMIT,
        hos_setting: typing.Optional[UpdateDriverRequestHosSetting] = OMIT,
        license_number: typing.Optional[str] = OMIT,
        license_state: typing.Optional[str] = OMIT,
        locale: typing.Optional[UpdateDriverRequestLocale] = OMIT,
        name: typing.Optional[str] = OMIT,
        notes: typing.Optional[str] = OMIT,
        password: typing.Optional[str] = OMIT,
        peer_group_tag_id: typing.Optional[str] = OMIT,
        phone: typing.Optional[str] = OMIT,
        static_assigned_vehicle_id: typing.Optional[str] = OMIT,
        tachograph_card_number: typing.Optional[str] = OMIT,
        tag_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        timezone: typing.Optional[str] = OMIT,
        us_driver_ruleset_override: typing.Optional[UsDriverRulesetOverride] = OMIT,
        username: typing.Optional[str] = OMIT,
        vehicle_group_tag_id: typing.Optional[str] = OMIT,
        waiting_time_duty_status_enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DriverResponse]:
        """
        Update a specific driver's information. This can also be used to activate or de-activate a given driver by setting the driverActivationStatus field. If the driverActivationStatus field is 'deactivated' then the user can also specify the deactivatedAtTime. The deactivatedAtTime cannot be more than 6 months in the past and must not come before the dirver's latest active HOS log. It will be considered an error if deactivatedAtTime is provided with a driverActivationStatus of active.

         **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href="https://forms.gle/zkD4NCH7HjKb7mm69" target="_blank">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href="https://www.samsara.com/help" target="_blank">submit a case</a> to our support team.

        To use this endpoint, select **Write Drivers** under the Drivers category when creating or editing an API token. <a href="https://developers.samsara.com/docs/authentication#scopes-for-api-tokens" target="_blank">Learn More.</a>

        Parameters
        ----------
        id : str
            ID of the driver. This can either be the Samsara-specified ID, or an external ID. External IDs are customer specified key-value pairs created in the POST or PATCH requests of this resource. To specify an external ID as part of a path parameter, use the following format: `key:value`. For example, `payrollId:ABFS18600`

        attributes : typing.Optional[typing.Sequence[CreateDriverRequestAttributes]]

        carrier_settings : typing.Optional[DriverCarrierSettings]

        current_id_card_code : typing.Optional[str]
            The ID Card Code on the back of the physical card assigned to the driver.  Contact Samsara if you would like to enable this feature.

        deactivated_at_time : typing.Optional[str]
            The date and time this driver is considered to be deactivated in RFC 3339 format.

        driver_activation_status : typing.Optional[UpdateDriverRequestDriverActivationStatus]
            A value indicating whether the driver is active or deactivated. Valid values: `active`, `deactivated`.

        eld_adverse_weather_exemption_enabled : typing.Optional[bool]
            Flag indicating this driver may use Adverse Weather exemptions in ELD logs.

        eld_big_day_exemption_enabled : typing.Optional[bool]
            Flag indicating this driver may use Big Day exemption in ELD logs.

        eld_day_start_hour : typing.Optional[int]
            `0` indicating midnight-to-midnight ELD driving hours, `12` to indicate noon-to-noon driving hours.

        eld_exempt : typing.Optional[bool]
            Flag indicating this driver is exempt from the Electronic Logging Mandate.

        eld_exempt_reason : typing.Optional[str]
            Reason that this driver is exempt from the Electronic Logging Mandate (see eldExempt).

        eld_pc_enabled : typing.Optional[bool]
            Flag indicating this driver may select the Personal Conveyance duty status in ELD logs.

        eld_ym_enabled : typing.Optional[bool]
            Flag indicating this driver may select the Yard Move duty status in ELD logs.

        external_ids : typing.Optional[typing.Dict[str, str]]
            The [external IDs](https://developers.samsara.com/docs/external-ids) for the given object.

        has_driving_features_hidden : typing.Optional[DriverHasDrivingFeaturesHidden]

        hos_setting : typing.Optional[UpdateDriverRequestHosSetting]

        license_number : typing.Optional[str]
            Driver's state issued license number. The combination of this number and `licenseState` must be unique.

        license_state : typing.Optional[str]
            Abbreviation of US state, Canadian province, or US territory that issued driver's license.

        locale : typing.Optional[UpdateDriverRequestLocale]
            Locale override (uncommon). These are specified by ISO 3166-2 country codes for supported locales. Valid values: `us`, `at`, `be`, `ca`, `gb`, `fr`, `de`, `ie`, `it`, `lu`, `mx`, `nl`, `es`, `ch`, `pr`.

        name : typing.Optional[str]
            Driver's name.

        notes : typing.Optional[str]
            Notes about the driver.

        password : typing.Optional[str]
            Password that the driver can use to login to the Samsara driver app.

        peer_group_tag_id : typing.Optional[str]
            The peer group tag id this driver belong to, leave blank to be in group with everyone, used for gamification.

        phone : typing.Optional[str]
            Phone number of the driver.

        static_assigned_vehicle_id : typing.Optional[str]
            ID of vehicle that the driver is permanently assigned to. (uncommon).

        tachograph_card_number : typing.Optional[str]
            Driver's assigned tachograph card number (Europe specific)

        tag_ids : typing.Optional[typing.Sequence[str]]
            IDs of tags the driver is associated with. If your access to the API is scoped by one or more tags, this field is required to pass in.

        timezone : typing.Optional[str]
            Home terminal timezone, in order to indicate what time zone should be used to calculate the ELD logs. Driver timezones use [IANA timezone database](https://www.iana.org/time-zones) keys (e.g. `America/Los_Angeles`, `America/New_York`, `Europe/London`, etc.). You can find a mapping of common timezone formats to IANA timezone keys [here](https://unicode.org/cldr/charts/latest/supplemental/zone_tzid.html).

        us_driver_ruleset_override : typing.Optional[UsDriverRulesetOverride]

        username : typing.Optional[str]
            Driver's login username into the driver app. The username may not contain spaces or the '@' symbol. The username must be unique.

        vehicle_group_tag_id : typing.Optional[str]
            Tag ID which determines which vehicles a driver will see when selecting vehicles.

        waiting_time_duty_status_enabled : typing.Optional[bool]
            Flag indicating this driver may select waiting time duty status in ELD logs

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DriverResponse]
            Updated driver object, with ID.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"fleet/drivers/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "attributes": convert_and_respect_annotation_metadata(
                    object_=attributes, annotation=typing.Sequence[CreateDriverRequestAttributes], direction="write"
                ),
                "carrierSettings": convert_and_respect_annotation_metadata(
                    object_=carrier_settings, annotation=DriverCarrierSettings, direction="write"
                ),
                "currentIdCardCode": current_id_card_code,
                "deactivatedAtTime": deactivated_at_time,
                "driverActivationStatus": driver_activation_status,
                "eldAdverseWeatherExemptionEnabled": eld_adverse_weather_exemption_enabled,
                "eldBigDayExemptionEnabled": eld_big_day_exemption_enabled,
                "eldDayStartHour": eld_day_start_hour,
                "eldExempt": eld_exempt,
                "eldExemptReason": eld_exempt_reason,
                "eldPcEnabled": eld_pc_enabled,
                "eldYmEnabled": eld_ym_enabled,
                "externalIds": external_ids,
                "hasDrivingFeaturesHidden": has_driving_features_hidden,
                "hosSetting": convert_and_respect_annotation_metadata(
                    object_=hos_setting, annotation=UpdateDriverRequestHosSetting, direction="write"
                ),
                "licenseNumber": license_number,
                "licenseState": license_state,
                "locale": locale,
                "name": name,
                "notes": notes,
                "password": password,
                "peerGroupTagId": peer_group_tag_id,
                "phone": phone,
                "staticAssignedVehicleId": static_assigned_vehicle_id,
                "tachographCardNumber": tachograph_card_number,
                "tagIds": tag_ids,
                "timezone": timezone,
                "usDriverRulesetOverride": convert_and_respect_annotation_metadata(
                    object_=us_driver_ruleset_override, annotation=UsDriverRulesetOverride, direction="write"
                ),
                "username": username,
                "vehicleGroupTagId": vehicle_group_tag_id,
                "waitingTimeDutyStatusEnabled": waiting_time_duty_status_enabled,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DriverResponse,
                    parse_obj_as(
                        type_=DriverResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
